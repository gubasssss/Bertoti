We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.


Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.


Oque é Engenharia de Software?

Engenharia de software vai além da programação, incluindo também modificação e manutenção do software ao longo do tempo. Ela considera tempo, escala e trade-offs , envolvendo decisões complexas e adaptação constante do software às mudanças. Em resumo, é o desenvolvimento de software que leva em conta seu ciclo de vida completo.

Oque é Escala,Tempo e Trade-Offs?


No contexto da engenharia de software, o tempo refere-se à consideração da passagem do tempo e da necessidade de mudanças futuras no software. Escala envolve preocupações com eficiência e dimensionamento, tanto no produto final quanto na organização que o desenvolve. Trade-offs se referem às decisões complexas que os engenheiros de software precisam tomar, pesando vantagens e desvantagens de diferentes abordagens, muitas vezes com base em estimativas imprecisas.

Exemplos de Trade-Offs:

-Segurança vs. Usabilidade: Adicionar camadas extras de segurança pode tornar o software mais seguro, mas também pode torná-lo menos fácil de usar para os usuários finais. Encontrar o equilíbrio certo entre segurança e usabilidade é um trade-off comum.

-Desenvolvimento rápido vs. Manutenibilidade: Desenvolver rapidamente um software pode resultar em um lançamento mais rápido no mercado, porém, se o código não for bem estruturado ou documentado, pode tornar a manutenção e atualização futuras mais difíceis e demoradas.

-Funcionalidade vs. Desempenho: Adicionar mais funcionalidades ao software pode aumentar sua utilidade para os usuários, mas também pode afetar negativamente o desempenho. Encontrar um equilíbrio entre funcionalidade e desempenho é essencial para garantir uma boa experiência do usuário.
